# empty
"""
URL page iterator utility

Given a URL like:
  https://bim.easyaccessmaterials.com/programs/fl2023/gradek/page0001.xhtml

This script replaces the last numeric sequence in the URL with a zero-padded page
number and exports the pages as PNG images.

Usage examples:
  python test.py "https://.../page0001.xhtml" --start 1 --count 5 --out-dir imgs
  python test.py "https://.../page0001.xhtml" --start 1 --end 20 --img-format png

If the URL doesn't contain digits, you can instead provide a pattern using
{page} and a width: ".../page{page:04d}.xhtml" (then width derives from format)
"""

from __future__ import annotations

import argparse
import re
import sys
from typing import Iterator, Optional

try:
    import requests
except Exception:
    requests = None  # optional; only required for --check-head

import os
from pathlib import Path


def replace_last_number(url: str, n: int, width: Optional[int] = None) -> str:
    """Replace the last contiguous digit-sequence in `url` with n, zero-padded.

    If width is None, the width is taken from the length of that digit sequence.
    Raises ValueError if no digit sequence is present.
    """
    matches = list(re.finditer(r"\d+", url))
    if not matches:
        raise ValueError("No numeric sequence found in URL to replace")
    last = matches[-1]
    original = last.group(0)
    if width is None:
        width = len(original)
    return url[: last.start()] + str(n).zfill(width) + url[last.end() :]


def generate_urls(
    template_url: str, start: int, end: Optional[int] = None, count: Optional[int] = None
) -> Iterator[str]:
    """Generate URLs from start to end (inclusive) or start..start+count-1.

    If template_url contains a format placeholder like {page:04d}, use that.
    Otherwise replace the last numeric sequence.
    """
    # detect python-style format placeholder
    if "{page" in template_url:
        # find width if provided
        fmt_match = re.search(r"\{page(?::0?(\d+)d)?\}", template_url)
        if fmt_match:
            width = int(fmt_match.group(1)) if fmt_match.group(1) else 0
        else:
            width = 0

        if end is None and count is None:
            raise ValueError("Either --end or --count must be provided when using {page}")
        if end is None:
            end = start + (count or 0) - 1

        for i in range(start, end + 1):
            if width:
                yield template_url.format(page=i)
            else:
                # no explicit width, just insert integer
                yield template_url.replace("{page}", str(i))
        return

    # otherwise, replace last numeric sequence
    # determine original width from last numeric sequence
    matches = list(re.finditer(r"\d+", template_url))
    if not matches:
        raise ValueError(
            "Template URL contains no digits and no {page} placeholder. Provide one of those."
        )
    original = matches[-1].group(0)
    width = len(original)

    if end is None and count is None:
        raise ValueError("Either --end or --count must be provided")
    if end is None:
        end = start + (count or 0) - 1

    for i in range(start, end + 1):
        yield replace_last_number(template_url, i, width)


def head_check(url: str, timeout: float = 6.0) -> int:
    """Return HTTP status for HEAD (falls back to GET if HEAD not allowed).
    If requests isn't installed, raise RuntimeError.
    """
    if requests is None:
        raise RuntimeError("requests library not available; install it to use --check-head")
    try:
        r = requests.head(url, allow_redirects=True, timeout=timeout)
        return r.status_code
    except Exception:
        # try GET as fallback
        try:
            r = requests.get(url, stream=True, timeout=timeout)
            r.close()
            return r.status_code
        except Exception:
            return 0





def generate_image_playwright(url: str, out_path: Path, img_format: str = "png", timeout: int = 30000, page_selector: Optional[str] = None, clip_padding: int = 0, full_page: bool = False) -> bool:
    """Render page to image using Playwright. img_format: 'png' or 'jpeg'."""
    try:
        from playwright.sync_api import sync_playwright
        import time

        with sync_playwright() as pw:
            browser = pw.chromium.launch(args=["--force-color-profile=srgb"])
            page = browser.new_page()
            # viewport close to A4 ratio for consistent scaling
            page.set_viewport_size({"width": 1240, "height": 1754})

            page.goto(url, wait_until="networkidle", timeout=timeout)

            # Wait a bit for dynamic content
            time.sleep(1)

            # Try to detect background-image on supplied selector (or fallback to body)
            selector = page_selector or '#PageContainer3'
            bg_info = page.evaluate(
                f"""
                () => {{
                    const el = document.querySelector('{selector}') || document.body;
                    if (!el) return null;
                    const style = window.getComputedStyle(el);
                    return {{
                        hasEl: !!document.querySelector('{selector}'),
                        backgroundImage: style.backgroundImage || null,
                        width: el.getBoundingClientRect().width,
                        height: el.getBoundingClientRect().height,
                        x: el.getBoundingClientRect().x,
                        y: el.getBoundingClientRect().y
                    }};
                }}
                """
            )

            # Inject CSS to ensure white page background fallback and proper image scaling
            page.add_style_tag(
                content=f"""
                html, body {{ margin: 0 !important; padding: 0 !important; background: #ffffff !important; }}
                img {{ max-width: 100% !important; height: auto !important; display: block !important; margin: 0 auto !important; }}
                .content-wrapper, main, article {{ width: 100% !important; max-width: none !important; margin: 0 !important; padding: 0 !important; background: #ffffff !important; }}
                {selector} {{ background-position: center !important; background-repeat: no-repeat !important; background-size: contain !important; }}
                """
            )

            # If there is a background image on PageContainer3, ensure it is preserved and sized to cover the element
            clip = None
            if bg_info and bg_info.get("backgroundImage") and bg_info.get("backgroundImage") != 'none':
                # Extract URL from background-image value
                bg_url = None
                m = None
                try:
                    import re as _re

                    m = _re.search(r'url\((?:"|\')?(.*?)(?:"|\')?\)', bg_info["backgroundImage"])
                except Exception:
                    m = None
                if m:
                    bg_url = m.group(1)

                if bg_url:
                    # Force the background-image explicitly and make it cover the element
                    page.add_style_tag(content=f"{selector} {{ background-image: url('{bg_url}') !important; background-size: cover !important; background-color: #ffffff !important; }}")

                # Clip to the element's bounding box so screenshot contains only the page
                try:
                    box = page.locator(selector).bounding_box()
                    if box:
                        # bounding_box values can be float; convert to ints
                        clip = {"x": int(box["x"]), "y": int(box["y"]), "width": int(box["width"]), "height": int(box["height"]) }
                except Exception:
                    clip = None

            # Take screenshot
            screenshot_args = {
                "path": str(out_path),
                "type": "jpeg" if img_format.lower() in ("jpeg", "jpg") else "png",
                "full_page": full_page
            }
            
            if img_format.lower() in ("jpeg", "jpg"):
                screenshot_args["quality"] = 90

            if not full_page and clip:
                # Add padding to clip area if specified
                screenshot_args["clip"] = {
                    "x": float(clip["x"] - clip_padding),
                    "y": float(clip["y"] - clip_padding),
                    "width": float(clip["width"] + (clip_padding * 2)),
                    "height": float(clip["height"] + (clip_padding * 2))
                }

            page.screenshot(**screenshot_args)
            browser.close()
        return True
    except Exception as e:
        print(f"Image generation error: {e}", file=sys.stderr)
        return False


def main(argv: Optional[list[str]] = None) -> int:
    p = argparse.ArgumentParser(description="Generate iterated page URLs and export to images")
    p.add_argument("url", help="Template URL or URL containing a numeric page to replace")
    p.add_argument("--start", "-s", type=int, default=None, help="Start page (default: value found in URL or 1)")
    p.add_argument("--end", "-e", type=int, help="End page (inclusive)")
    p.add_argument("--count", "-c", type=int, help="Number of pages to generate")
    p.add_argument("--print-only", action="store_true", help="Only print URLs (default)")
    p.add_argument("--check-head", action="store_true", help="Perform HEAD request and print status codes (requires requests)")
    p.add_argument("--limit", "-l", type=int, help="Stop early after this many URLs printed/generated")
    p.add_argument("--out-dir", type=str, default="imgs", help="Output directory for generated images")
    p.add_argument("--img-format", type=str, default="png", choices=["png","jpeg"], help="Image format (PNG or JPEG)")
    p.add_argument("--img-prefix", type=str, default="page", help="Filename prefix for generated images")
    p.add_argument("--clip-padding", type=int, default=0, help="Add padding in pixels around clipped content")
    p.add_argument("--img-fullpage", action="store_true", help="Capture full page instead of clipping to content")
    p.add_argument("--skip-existing", action="store_true", help="Skip image creation when output file already exists")
    args = p.parse_args(argv)

    url = args.url

    # try to deduce start from URL's last number if present
    m = list(re.finditer(r"\d+", url))
    if args.start is not None:
        start = args.start
    elif m:
        start = int(m[-1].group(0))
    else:
        start = 1

    if args.end is None and args.count is None and args.limit is None:
        # default to small demo if nothing provided
        end = start + 9
    else:
        end = args.end

    count = args.count

    gen = generate_urls(url, start, end=end, count=count)

    printed = 0
    
    # Create output directory if we're generating images
    out_dir_path = None
    if not args.print_only:
        try:
            from playwright.sync_api import sync_playwright  # type: ignore
        except ImportError:
            print("Playwright is required for image export. Install playwright and browsers.", file=sys.stderr)
            return 3
            
        out_dir_path = Path(args.out_dir)
        out_dir_path.mkdir(parents=True, exist_ok=True)
    for u in gen:
        if args.check_head:
            try:
                status = head_check(u)
            except RuntimeError as exc:
                print("Error: ", exc, file=sys.stderr)
                return 2
            print(f"{u}  -> {status}")
        else:
            print(u)

        # extract last numeric group to use for filename and for selector
        m = list(re.finditer(r"\d+", u))
        if m:
            raw_page = m[-1].group(0)            # e.g. '0003'
            page_str = raw_page                  # keep padded form for filenames
            page_index = str(int(raw_page))      # numeric form without leading zeros for selector
        else:
            page_str = str(printed + 1)
            page_index = page_str

        page_selector = f"#PageContainer{page_index}"

        # Generate image
        if not args.print_only:
            img_name = f"{args.img_prefix}{page_str}.{('jpg' if args.img_format == 'jpeg' else 'png')}"
            img_path = out_dir_path / img_name
            if args.skip_existing and img_path.exists():
                print(f"Skipping existing {img_path}")
            else:
                img_success = generate_image_playwright(
                    u, 
                    img_path, 
                    img_format=args.img_format, 
                    page_selector=page_selector,
                    clip_padding=args.clip_padding,
                    full_page=args.img_fullpage
                )
                if img_success:
                    print(f"Wrote image: {img_path}")
                else:
                    print(f"Failed to write image for {u}", file=sys.stderr)

        printed += 1
        if args.limit and printed >= args.limit:
            break

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
